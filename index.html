<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Route Algorithm Visualizer</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #f4f7f6; /* Light greenish-gray background */
        overflow-x: hidden;
      }

      .header {
        background-color: white;
        padding: 1rem 2rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        font-size: 1.25rem;
        font-weight: 600;
        color: #1f2937;
      }

      .main-content {
        display: flex;
        flex-direction: column; /* Default for mobile */
        padding: 1rem;
        gap: 1rem;
        flex-grow: 1; /* Allow main content to fill space */
      }

      @media (min-width: 1024px) {
        /* lg breakpoint */
        .main-content {
          flex-direction: row;
        }
      }

      .map-column {
        flex-basis: 100%; /* Full width on mobile */
        position: relative; /* For search overlay */
      }
      @media (min-width: 1024px) {
        /* lg breakpoint */
        .map-column {
          flex-basis: 65%; /* 65% width on large screens */
        }
      }

      #map {
        height: 75vh; /* Increased map height */
        width: 100%;
        border-radius: 0.75rem; /* More rounded map */
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
      }
      .leaflet-container {
        background: #e5e7eb;
        border-radius: 0.75rem;
      }

      /* Search Overlay Styles */
      #searchOverlay {
        position: absolute;
        top: 1.5rem; /* Slightly more padding from top */
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        width: 90%;
        max-width: 450px; /* Slightly narrower */
      }
      #locationSearchInputContainer {
        display: flex;
        align-items: center; /* Vertically align items */
        background-color: white;
        border-radius: 0.5rem;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        padding-left: 0.75rem; /* Space for potential icon */
      }
      #locationSearchInput {
        flex-grow: 1;
        border: none;
        padding: 0.875rem 0.75rem; /* Adjusted padding */
        font-size: 0.9375rem; /* Slightly smaller font */
        outline: none;
        background-color: transparent;
      }
      /* Placeholder for a search icon if needed */
      /* #locationSearchInputContainer::before { content: 'üîç'; margin-right: 0.5rem; color: #9ca3af; } */

      #searchSuggestions {
        list-style: none;
        padding: 0;
        margin: 0.5rem 0 0 0;
        background-color: white;
        border-radius: 0.5rem;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        max-height: 220px; /* Increased max height */
        overflow-y: auto;
      }
      #searchSuggestions li {
        padding: 0.875rem 1rem;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0; /* Lighter border */
        font-size: 0.875rem;
      }
      #searchSuggestions li:last-child {
        border-bottom: none;
      }
      #searchSuggestions li:hover {
        background-color: #f9fafb;
      }
      /* End Search Overlay Styles */

      .controls-column {
        flex-basis: 100%; /* Full width on mobile */
        overflow-y: auto; /* Scroll if content overflows */
        max-height: calc(
          100vh - 4rem - 2rem
        ); /* Adjust based on header and padding */
        padding-right: 0.5rem; /* Space for scrollbar */
      }
      @media (min-width: 1024px) {
        /* lg breakpoint */
        .controls-column {
          flex-basis: 35%; /* 35% width on large screens */
        }
      }

      .control-card {
        background-color: white;
        border-radius: 0.75rem;
        padding: 1.25rem; /* Slightly reduced padding */
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.07),
          0 2px 4px -1px rgba(0, 0, 0, 0.04);
        margin-bottom: 1.25rem;
      }

      .btn {
        padding: 0.625rem 1.125rem;
        border-radius: 0.375rem; /* Less rounded for a slightly sharper look */
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s ease-in-out;
        margin: 0.25rem 0; /* Vertical margin */
        border: 1px solid transparent;
        text-align: center;
        display: block; /* Make buttons block for full width */
        width: 100%;
      }
      .btn:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
      }

      .btn-primary {
        background-color: #2563eb;
        color: white;
      } /* Slightly darker blue */
      .btn-primary:hover {
        background-color: #1d4ed8;
      }

      .btn-secondary {
        background-color: #059669;
        color: white;
      } /* Slightly darker green */
      .btn-secondary:hover {
        background-color: #047857;
      }

      .btn-danger {
        background-color: #dc2626;
        color: white;
      } /* Slightly darker red */
      .btn-danger:hover {
        background-color: #b91c1c;
      }

      .btn-outline {
        border-color: #cbd5e1;
        color: #334155;
        background-color: white;
      } /* Slate colors */
      .btn-outline:hover {
        background-color: #f1f5f9;
        border-color: #94a3b8;
      }

      .btn-remove-point, .btn-remove-via-point {
        background-color: transparent;
        color: #ef4444;
        padding: 0.25rem 0.5rem;
        font-size: 1rem; /* Larger X */
        font-weight: bold;
        border-radius: 9999px; /* Circle */
        margin-left: 0.5rem;
        line-height: 1;
        width: auto; /* Override block for this specific button */
        display: inline-block;
      }
      .btn-remove-point:hover, .btn-remove-via-point:hover {
        background-color: #fee2e2;
        color: #dc2626;
      }

      select {
        padding: 0.625rem;
        border-radius: 0.375rem;
        border: 1px solid #cbd5e1;
        margin: 0.25rem 0;
        width: 100%;
        box-sizing: border-box;
        background-color: white;
      }
      select:focus {
        border-color: #2563eb;
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
        outline: none;
      }

      .result-item {
        padding: 0.75rem;
        margin-bottom: 0.75rem;
        border-radius: 0.5rem;
        border: 1px solid #e2e8f0; /* Lighter border */
        background-color: #f8fafc; /* Very light gray */
        display: flex;
        align-items: center;
        font-size: 0.875rem;
      }
      .color-box {
        display: inline-block;
        width: 1.125em;
        height: 1.125em;
        margin-right: 0.625em;
        border: 1px solid #d1d5db;
        border-radius: 0.25rem;
      }
      #messageBox {
        position: fixed;
        top: 1.5rem;
        left: 50%;
        transform: translateX(-50%);
        padding: 0.875rem 1.5rem;
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        z-index: 10001;
        opacity: 0;
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        pointer-events: none;
        transform: translateX(-50%) translateY(-20px);
      }
      #messageBox.show {
        opacity: 1;
        pointer-events: auto;
        transform: translateX(-50%) translateY(0);
      }
      .leaflet-routing-container {
        max-height: 150px;
        overflow-y: auto;
        border-radius: 0.375rem;
        border: 1px solid #e5e7eb;
        font-size: 0.875rem;
      }
      .section-title {
        font-size: 1.125rem; /* text-lg */
        font-weight: 600;
        margin-bottom: 1rem;
        color: #1e293b; /* Slate 800 */
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 0.5rem;
      }
      .subsection-title {
        font-size: 0.9375rem; /* Between sm and base */
        font-weight: 500;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        color: #475569; /* Slate 600 */
      }
      .points-list-item, .via-points-list-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.375rem 0.25rem; /* Adjusted padding */
        font-size: 0.875rem;
        border-bottom: 1px dashed #e2e8f0;
      }
      .points-list-item:last-child, .via-points-list-item:last-child {
        border-bottom: none;
      }

      /* Custom style for MST and Path edge labels */
      .edge-label {
        background-color: rgba(255, 255, 255, 0.85) !important;
        border: none !important;
        border-radius: 3px !important;
        box-shadow: none !important;
        color: #333 !important;
        font-size: 10px !important;
        font-weight: bold !important;
        padding: 1px 3px !important;
        white-space: nowrap !important;
      }
      .edge-label::before { /* Hide default tooltip pointer */
        display: none !important;
      }
    </style>
  </head>
  <body class="h-screen flex flex-col">
    <header class="header">Route Algorithm Visualizer</header>

    <div id="messageBox"></div>

    <main class="main-content">
      <div class="map-column">
        <div id="map"></div>
        <div id="searchOverlay">
          <div id="locationSearchInputContainer">
            <input
              type="text"
              id="locationSearchInput"
              placeholder="Search for a location..."
              class="w-full"
            />
          </div>
          <ul id="searchSuggestions" class="hidden"></ul>
        </div>
      </div>

      <div class="controls-column">
        <div class="control-card">
          <h2 class="section-title">Route Configuration</h2>
          <button id="addPointMode" class="btn btn-primary mb-3">
            Mode: Add Points
          </button>

          <h3 class="subsection-title mb-2">Placed Points:</h3>
          <ul
            id="pointsList"
            class="text-sm text-gray-700 max-h-48 overflow-y-auto space-y-1 pr-2 mb-3"
          ></ul>
          <button id="resetPoints" class="btn btn-danger">
            Clear All Points & Paths
          </button>
        </div>

        <div class="control-card">
          <h2 class="section-title">Algorithm Execution</h2>
          <div class="grid grid-cols-2 gap-2">
            <div class="mb-3">
              <label
                for="startNodeSelect"
                class="block text-xs font-medium text-gray-700 mb-1"
                >Start Point</label
              >
              <select
                id="startNodeSelect"
                class="w-full p-2.5 border border-gray-300 rounded-md shadow-sm bg-white hover:bg-gray-50"
              ></select>
            </div>
            <div class="mb-4">
              <label
                for="endNodeSelect"
                class="block text-xs font-medium text-gray-700 mb-1"
                >End Point</label
              >
              <select
                id="endNodeSelect"
                class="w-full p-2.5 border border-gray-300 rounded-md shadow-sm bg-white hover:bg-gray-50"
              ></select>
            </div>
          </div>
          
          <h3 class="subsection-title mt-3">Via Points (Optional)</h3>
          <div class="mb-2">
              <label for="viaPointSelect" class="block text-xs font-medium text-gray-700 mb-1">Add Via Point</label>
              <div class="flex gap-2">
                  <select id="viaPointSelect" class="flex-grow p-2.5 border border-gray-300 rounded-md shadow-sm bg-white hover:bg-gray-50"></select>
                  <button id="addViaPointBtn" class="btn btn-outline px-3 py-2 text-sm !w-auto">Add</button>
              </div>
          </div>
          <ul id="viaPointsListUI" class="text-sm text-gray-700 max-h-24 overflow-y-auto space-y-1 pr-2 mb-2 border border-gray-200 rounded-md p-2 bg-gray-50 min-h-[2.5rem]">
              <li class="text-gray-400 italic no-via-points-placeholder">No via points added.</li>
          </ul>
          <button id="clearViaPointsBtn" class="btn btn-outline text-xs py-1 !w-auto self-end">Clear Via Points</button>


          <h3 class="subsection-title mt-4">Abstract Graph Algorithms (Sequential)</h3>
          <div class="grid grid-cols-2 gap-2 mb-3">
            <button id="runBFS" class="btn btn-secondary mb-3">BFS</button>
            <button id="runDAGSP" class="btn btn-secondary mb-3">
              Directed Acyclic Graph
            </button>
          </div>

          <h3 class="subsection-title">Minimum Spanning Tree</h3>
          <p class="text-xs text-gray-500 mb-2">Operates on Start, End, and Via points if Via points are selected. Otherwise, uses all placed points.</p>
          <div class="grid grid-cols-2 gap-2">
            <button id="runPrims" class="btn btn-secondary mb-3">Prim's</button>
            <button id="runKruskals" class="btn btn-secondary mb-3">
              Kruskal's
            </button>
          </div>

          <h3 class="subsection-title">Road Network Algorithm</h3>
          <p class="text-xs text-gray-500 mb-2">If Via points are selected, uses Start -> Vias -> End. Otherwise, routes through all placed points in their original placement order.</p>
          <button id="runRoadRoute" class="btn btn-secondary mb-3">
            Find Road Route
          </button>
        </div>

        <div class="control-card">
          <h2 class="section-title">Results & Comparison</h2>
          <div id="resultsDisplay" class="text-sm space-y-2"></div>
        </div>
      </div>
    </main>

    <script>
      // --- Global Variables ---
      let map;
      let nodes = []; 
      let drawnPathLayers = L.featureGroup();
      let currentMode = "addPoint";
      let nextNodeId = 1;
      let lrmControl = null;
      const messageBox = document.getElementById("messageBox");
      let searchTimeout = null;
      let selectedViaPoints = []; // Array to store IDs of selected via points

      const algorithmColors = {
        BFS: "#3b82f6", 
        DAG_SP: "#ec4899",
        PRIMS: "#f97316",
        KRUSKALS: "#8b5cf6",
        ROAD_ROUTE: "#14b8a6",
      };

      // --- Map Initialization ---
      function initMap() {
        map = L.map("map").setView([-7.2575, 112.7521], 13);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution:
            '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        }).addTo(map);
        drawnPathLayers.addTo(map);
        map.on("click", handleMapClick);
        map.on("click", () =>
          document.getElementById("searchSuggestions").classList.add("hidden")
        );
      }

      // --- UI Element Getters ---
      const locationSearchInput = document.getElementById("locationSearchInput");
      const searchSuggestionsList = document.getElementById("searchSuggestions");
      const addPointModeBtn = document.getElementById("addPointMode");
      const resetPointsBtn = document.getElementById("resetPoints");
      const startNodeSelect = document.getElementById("startNodeSelect");
      const endNodeSelect = document.getElementById("endNodeSelect");
      const pointsListUI = document.getElementById("pointsList");
      const resultsDisplay = document.getElementById("resultsDisplay");
      const viaPointSelect = document.getElementById("viaPointSelect");
      const addViaPointBtn = document.getElementById("addViaPointBtn");
      const viaPointsListUI = document.getElementById("viaPointsListUI");
      const clearViaPointsBtn = document.getElementById("clearViaPointsBtn");


      // --- Event Listeners Setup ---
      function setupEventListeners() {
        locationSearchInput.addEventListener("input", handleSearchInput);
        locationSearchInput.addEventListener("focus", () => {
          if (locationSearchInput.value.trim().length > 2)
            fetchSearchSuggestions();
        });
        searchSuggestionsList.addEventListener("click", handleSuggestionClick);
        document
          .getElementById("searchOverlay")
          .addEventListener("focusout", (e) => {
            if (
              !document.getElementById("searchOverlay").contains(e.relatedTarget)
            ) {
              searchSuggestionsList.classList.add("hidden");
            }
          });

        addPointModeBtn.addEventListener("click", () => {
          currentMode = "addPoint";
          updateModeDisplay();
        });
        resetPointsBtn.addEventListener("click", resetAll);

        document
          .getElementById("runBFS")
          .addEventListener("click", () => runSequentialPathfindingAlgorithm("BFS"));
        document
          .getElementById("runDAGSP")
          .addEventListener("click", () => runSequentialPathfindingAlgorithm("DAG_SP"));
        document
          .getElementById("runRoadRoute")
          .addEventListener("click", runRoadRouteSequential);
        document
          .getElementById("runPrims")
          .addEventListener("click", () => runMST("PRIMS"));
        document
          .getElementById("runKruskals")
          .addEventListener("click", () => runMST("KRUSKALS"));
        pointsListUI.addEventListener("click", handlePointListActions);

        addViaPointBtn.addEventListener('click', handleAddViaPoint);
        viaPointsListUI.addEventListener('click', handleViaPointListActions);
        clearViaPointsBtn.addEventListener('click', handleClearViaPoints);

        startNodeSelect.addEventListener('change', () => {
            updateViaPointSelectorOptions(); 
            clearAllDrawnPathsAndResults();
        });
        endNodeSelect.addEventListener('change', () => {
            updateViaPointSelectorOptions(); 
            clearAllDrawnPathsAndResults();
        });
      }


      // --- Location Search with Autocomplete ---
      function handleSearchInput() {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          fetchSearchSuggestions();
        }, 300);
      }

      async function fetchSearchSuggestions() {
        const query = locationSearchInput.value.trim();
        if (query.length < 3) {
          searchSuggestionsList.innerHTML = "";
          searchSuggestionsList.classList.add("hidden");
          return;
        }
        try {
          const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
              query
            )}&limit=5&addressdetails=1`
          );
          if (!response.ok) {
            throw new Error(`Nominatim API error: ${response.statusText}`);
          }
          const data = await response.json();
          displaySearchSuggestions(data);
        } catch (error) {
          console.error("Error fetching suggestions:", error);
          showMessage("Error fetching location suggestions.", "error");
          searchSuggestionsList.innerHTML = "";
          searchSuggestionsList.classList.add("hidden");
        }
      }

      function displaySearchSuggestions(suggestions) {
        searchSuggestionsList.innerHTML = "";
        if (suggestions && suggestions.length > 0) {
          suggestions.forEach((place) => {
            const li = document.createElement("li");
            li.textContent = place.display_name;
            li.dataset.lat = place.lat;
            li.dataset.lon = place.lon;
            li.dataset.boundingbox = JSON.stringify(place.boundingbox);
            searchSuggestionsList.appendChild(li);
          });
          searchSuggestionsList.classList.remove("hidden");
        } else {
          searchSuggestionsList.classList.add("hidden");
        }
      }

      function handleSuggestionClick(event) {
        if (event.target.tagName === "LI") {
          event.stopPropagation();
          const targetLi = event.target;
          const lat = parseFloat(targetLi.dataset.lat);
          const lon = parseFloat(targetLi.dataset.lon);
          const boundingboxString = targetLi.dataset.boundingbox;

          if (!boundingboxString) {
            console.error("Bounding box data is missing for this suggestion.");
            if (lat && lon) map.setView([lat, lon], 13);
            showMessage("Navigated to point (bounding box data was missing).", "info");
            return;
          }

          try {
            const boundingbox = JSON.parse(boundingboxString);
            if (!Array.isArray(boundingbox) || boundingbox.length !== 4) {
              if (lat && lon) map.setView([lat, lon], 13);
              throw new Error("Invalid bounding box format from API");
            }
            const bounds = [
              [parseFloat(boundingbox[0]), parseFloat(boundingbox[2])],
              [parseFloat(boundingbox[1]), parseFloat(boundingbox[3])],
            ];
            const latDiff = Math.abs(bounds[1][0] - bounds[0][0]);
            const lonDiff = Math.abs(bounds[1][1] - bounds[0][1]);
            if (latDiff < 0.0001 && lonDiff < 0.0001 && lat && lon) {
              map.setView([lat, lon], 15);
            } else {
              map.fitBounds(bounds);
            }
            showMessage(`Navigated to: ${targetLi.textContent.substring(0,50)}...`, "success");
          } catch (e) {
            console.error("Error processing suggestion data:", e);
            if (lat && lon) map.setView([lat, lon], 13);
            showMessage("Error navigating to suggestion. Displaying point.", "error");
          } finally {
            locationSearchInput.value = "";
            searchSuggestionsList.innerHTML = "";
            searchSuggestionsList.classList.add("hidden");
          }
        }
      }

      function showMessage(message, type = "info", duration = 3000) {
        messageBox.textContent = message;
        messageBox.style.backgroundColor =
          type === "error"
            ? "#ef4444"
            : type === "success"
            ? "#22c55e"
            : type === "info"
            ? "#3b82f6"
            : type === "warning"
            ? "#f97316" 
            : "#6b7280";
        messageBox.style.color = "white";
        messageBox.classList.add("show");
        setTimeout(() => messageBox.classList.remove("show"), duration);
      }

      function updateModeDisplay() {
        addPointModeBtn.textContent = `Mode: ${
          currentMode === "addPoint" ? "Add Points" : "N/A"
        }`;
      }

      function handleMapClick(e) {
        if (
          document
            .getElementById("searchOverlay")
            .contains(e.originalEvent.target)
        ) {
          return;
        }
        if (currentMode === "addPoint") {
          const nodeId = nextNodeId++;
          const nodeName = `P${nodeId}`;
          const marker = L.marker(e.latlng, { draggable: false })
            .addTo(map)
            .bindPopup(
              `Point ${nodeName} (${e.latlng.lat.toFixed(
                4
              )}, ${e.latlng.lng.toFixed(4)})`
            )
            .openPopup();
          nodes.push({
            id: nodeId,
            name: nodeName,
            lat: e.latlng.lat,
            lng: e.latlng.lng,
            marker: marker,
            originalIndex: nodes.length - 1, 
          });
          updatePointSelectors(); 
          updatePointsListUI();
          clearAllDrawnPathsAndResults();
        }
      }

      function updatePointSelectors() {
        const currentStartVal = startNodeSelect.value;
        const currentEndVal = endNodeSelect.value;

        startNodeSelect.innerHTML = "";
        endNodeSelect.innerHTML = "";
        
        nodes.forEach((node) => {
          const optionStart = document.createElement("option");
          optionStart.value = node.id;
          optionStart.textContent = node.name;
          startNodeSelect.appendChild(optionStart);

          const optionEnd = document.createElement("option");
          optionEnd.value = node.id;
          optionEnd.textContent = node.name;
          endNodeSelect.appendChild(optionEnd);
        });

        if (nodes.find((n) => n.id === parseInt(currentStartVal))) {
          startNodeSelect.value = currentStartVal;
        }
        if (nodes.find((n) => n.id === parseInt(currentEndVal))) {
          endNodeSelect.value = currentEndVal;
        } else if (nodes.length > 1 && startNodeSelect.value && nodes.find(n => n.id !== parseInt(startNodeSelect.value))) {
           const differentNodes = nodes.filter(n => n.id !== parseInt(startNodeSelect.value));
           if (differentNodes.length > 0) endNodeSelect.value = differentNodes[differentNodes.length -1].id;
           else if (nodes.length > 0) endNodeSelect.value = nodes[nodes.length-1].id;
        } else if (nodes.length > 0) {
           endNodeSelect.value = nodes[nodes.length - 1].id;
        }
        updateViaPointSelectorOptions(); 
        updateViaPointsListUI(); 
      }

       function updateViaPointSelectorOptions() {
        const currentViaVal = viaPointSelect.value;
        viaPointSelect.innerHTML = '<option value="">Select a via point...</option>';
        const startId = parseInt(startNodeSelect.value);
        const endId = parseInt(endNodeSelect.value);

        nodes.forEach(node => {
            if (node.id !== startId && node.id !== endId && !selectedViaPoints.includes(node.id)) {
                const optionVia = document.createElement("option");
                optionVia.value = node.id;
                optionVia.textContent = node.name;
                viaPointSelect.appendChild(optionVia);
            }
        });
         if (nodes.find(n => n.id === parseInt(currentViaVal)) && 
            parseInt(currentViaVal) !== startId && 
            parseInt(currentViaVal) !== endId && 
            !selectedViaPoints.includes(parseInt(currentViaVal))) {
            viaPointSelect.value = currentViaVal;
        }
    }


      function updatePointsListUI() {
        pointsListUI.innerHTML =
          nodes.length === 0
            ? '<li class="text-gray-500">No points added yet. Click map to add.</li>'
            : nodes
                .map(
                  (n) => `
                  <li class="points-list-item" data-node-id="${n.id}">
                      <span>${n.name}: (${n.lat.toFixed(3)}, ${n.lng.toFixed(3)})</span>
                      <button class="btn-remove-point" data-remove-id="${
                        n.id
                      }" title="Remove ${n.name}">√ó</button>
                  </li>
                `
                )
                .join("");
      }

      function handlePointListActions(event) {
        if (event.target.matches("[data-remove-id]")) {
          const nodeIdToRemove = parseInt(event.target.dataset.removeId);
          removePoint(nodeIdToRemove);
        }
      }

      function removePoint(nodeId) {
        const nodeIndex = nodes.findIndex((n) => n.id === nodeId);
        if (nodeIndex === -1) return;

        const nodeToRemove = nodes[nodeIndex];
        map.removeLayer(nodeToRemove.marker);
        nodes.splice(nodeIndex, 1);
        
        selectedViaPoints = selectedViaPoints.filter(id => id !== nodeId);
        nodes.forEach((node, index) => (node.originalIndex = index));

        updatePointSelectors(); 
        updatePointsListUI();
        clearAllDrawnPathsAndResults();
        showMessage(`Point ${nodeToRemove.name} removed.`, "info", 2000);
      }

      function handleAddViaPoint() {
        const selectedId = parseInt(viaPointSelect.value);
        if (!selectedId) {
            showMessage("Please select a point to add as a via point.", "info");
            return;
        }
        if (selectedId === parseInt(startNodeSelect.value) || selectedId === parseInt(endNodeSelect.value)) {
            showMessage("Via point cannot be the same as Start or End point.", "warning");
            return;
        }
        if (selectedViaPoints.includes(selectedId)) {
            showMessage("This point is already in the via list.", "info");
            return;
        }
        selectedViaPoints.push(selectedId);
        updateViaPointsListUI();
        updateViaPointSelectorOptions(); 
        clearAllDrawnPathsAndResults();
      }

      function updateViaPointsListUI() {
        const placeholder = viaPointsListUI.querySelector('.no-via-points-placeholder');
        if (selectedViaPoints.length === 0) {
            if (!placeholder) { 
                 viaPointsListUI.innerHTML = '<li class="text-gray-400 italic no-via-points-placeholder">No via points added.</li>';
            } else { 
                viaPointsListUI.innerHTML = '';
                viaPointsListUI.appendChild(placeholder);
            }
            return;
        }
        
        if(placeholder) placeholder.remove(); 
        viaPointsListUI.innerHTML = ""; 

        selectedViaPoints.forEach((nodeId, index) => {
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                const li = document.createElement("li");
                li.classList.add("via-points-list-item");
                li.dataset.viaNodeId = nodeId;
                li.innerHTML = `
                    <span>${index + 1}. ${node.name}</span>
                    <button class="btn-remove-via-point" data-remove-via-id="${nodeId}" title="Remove ${node.name}">√ó</button>
                `;
                viaPointsListUI.appendChild(li);
            }
        });
      }
      
      function handleViaPointListActions(event) {
        if (event.target.matches("[data-remove-via-id]")) {
            const nodeIdToRemove = parseInt(event.target.dataset.removeViaId);
            selectedViaPoints = selectedViaPoints.filter(id => id !== nodeIdToRemove);
            updateViaPointsListUI();
            updateViaPointSelectorOptions(); 
            clearAllDrawnPathsAndResults();
        }
      }

      function handleClearViaPoints() {
        selectedViaPoints = [];
        updateViaPointsListUI();
        updateViaPointSelectorOptions(); 
        clearAllDrawnPathsAndResults();
        showMessage("All via points cleared.", "info");
      }

      function clearAllDrawnPathsAndResults() {
        drawnPathLayers.clearLayers();
        if (lrmControl) {
          map.removeControl(lrmControl);
          lrmControl = null;
        }
        resultsDisplay.innerHTML = "";
      }

      function resetAll() {
        nodes.forEach((node) => map.removeLayer(node.marker));
        nodes = [];
        selectedViaPoints = [];
        nextNodeId = 1;
        clearAllDrawnPathsAndResults();
        updatePointSelectors(); 
        updatePointsListUI();
        currentMode = "addPoint";
        updateModeDisplay();
        locationSearchInput.value = "";
        searchSuggestionsList.innerHTML = "";
        searchSuggestionsList.classList.add("hidden");
        showMessage("Map and all points cleared.", "info");
      }

      function getWaypointSequence(startNodeId, endNodeId, isForRoadRoute = false, viaPointIdsArg = []) {
        const viaPointIds = [...viaPointIdsArg]; 

        if (nodes.length === 0) {
          if (!isForRoadRoute && viaPointIds.length === 0) showMessage("Please add points to the map first.", "error");
          return null;
        }
        const startNode = nodes.find(n => n.id === startNodeId);
        const endNode = nodes.find(n => n.id === endNodeId);

        if (!startNode || !endNode) {
          if (!isForRoadRoute && viaPointIds.length === 0) showMessage("Selected start or end node not found for sequence.", "error");
          return null;
        }

        let finalSequenceNodes = [];
        if (startNode) finalSequenceNodes.push(startNode);

        viaPointIds.forEach(vid => {
            const viaNode = nodes.find(n => n.id === vid);
            if (viaNode) {
                if (!finalSequenceNodes.length || finalSequenceNodes[finalSequenceNodes.length - 1].id !== viaNode.id) {
                    finalSequenceNodes.push(viaNode);
                }
            }
        });
        
        if (endNode) {
            if (!finalSequenceNodes.length || finalSequenceNodes[finalSequenceNodes.length - 1].id !== endNode.id) {
                 finalSequenceNodes.push(endNode);
            }
        }
        
        finalSequenceNodes = finalSequenceNodes.filter((item, index, arr) => {
            return index === 0 || item.id !== arr[index-1].id;
        });


        if (finalSequenceNodes.length === 1 && startNode.id === endNode.id && viaPointIds.length === 0) {
          if (!isForRoadRoute) showMessage(`Path from ${startNode.name} to itself is 0m.`, "info");
          return [startNode];
        }
        
        if (finalSequenceNodes.length < 2 && !(startNode.id === endNode.id && viaPointIds.length === 0) ) {
             if (!isForRoadRoute) showMessage("The defined sequence requires at least two distinct points.", "info");
             return null;
        }
         if (finalSequenceNodes.length < 1) return null;

        // The strict originalIndex check for RoadRoute is removed here.
        // Leaflet Routing Machine will handle the arbitrary sequence.
        // if (isForRoadRoute) {
        //     for(let i=0; i < finalSequenceNodes.length - 1; i++) {
        //         if (finalSequenceNodes[i].originalIndex > finalSequenceNodes[i+1].originalIndex) {
        //              showMessage( "For sequential road routing, all waypoints in the final sequence must follow their original placement order.", "error" );
        //              return null;
        //         }
        //     }
        // }
        return finalSequenceNodes;
      }


      function getDistance(node1, node2) {
        const latLng1 = L.latLng(node1.lat, node1.lng);
        const latLng2 = L.latLng(node2.lat, node2.lng);
        return latLng1.distanceTo(latLng2);
      }
      
      function buildUndirectedGraphFromSpecificNodes(specificNodes) {
        const adjList = {};
        specificNodes.forEach((node) => (adjList[node.id] = []));
        for (let i = 0; i < specificNodes.length; i++) {
            for (let j = i + 1; j < specificNodes.length; j++) {
                const node1 = specificNodes[i];
                const node2 = specificNodes[j];
                const distance = getDistance(node1, node2);
                adjList[node1.id].push({ neighborId: node2.id, weight: distance });
                adjList[node2.id].push({ neighborId: node1.id, weight: distance });
            }
        }
        return adjList;
    }


      function buildUndirectedGraphFromAllNodes() {
        return buildUndirectedGraphFromSpecificNodes(nodes);
      }

      function buildDirectedAcyclicGraphFromAllNodes() {
        const adj = {};
        const inDegree = {};
        const nodeIds = new Set();
        const sortedNodesByOriginalIndex = [...nodes].sort((a,b) => a.originalIndex - b.originalIndex);

        sortedNodesByOriginalIndex.forEach((node) => {
          adj[node.id] = [];
          inDegree[node.id] = 0;
          nodeIds.add(node.id);
        });

        for (let i = 0; i < sortedNodesByOriginalIndex.length; i++) {
          for (let j = i + 1; j < sortedNodesByOriginalIndex.length; j++) {
            const node1 = sortedNodesByOriginalIndex[i];
            const node2 = sortedNodesByOriginalIndex[j];
            const distance = getDistance(node1, node2);
            adj[node1.id].push({ neighborId: node2.id, weight: distance });
            inDegree[node2.id]++;
          }
        }
        return { adj, inDegree, nodeIds };
      }
      
      function formatDistance(meters) {
        if (isNaN(meters) || typeof meters !== 'number') return "";
        if (meters < 1000) {
            return meters.toFixed(0) + " m";
        } else {
            return (meters / 1000).toFixed(2) + " km";
        }
      }

      function drawPathSegment(pathNodeIds, color) {
        if (!pathNodeIds || pathNodeIds.length < 2) return 0;
        
        let totalSegmentLength = 0;
        for (let i = 0; i < pathNodeIds.length - 1; i++) {
            const nodeA = nodes.find((n) => n.id === pathNodeIds[i]);
            const nodeB = nodes.find((n) => n.id === pathNodeIds[i + 1]);

            if (nodeA && nodeB) {
                const singleHopLatLngs = [[nodeA.lat, nodeA.lng], [nodeB.lat, nodeB.lng]];
                const hopDistance = getDistance(nodeA, nodeB);
                totalSegmentLength += hopDistance;

                const polyline = L.polyline(singleHopLatLngs, {
                    color: color,
                    weight: 5,
                    opacity: 0.75,
                    dashArray: "1,0", 
                });

                const weightText = formatDistance(hopDistance);
                polyline.bindTooltip(weightText, {
                    permanent: true,
                    direction: 'center',
                    className: 'edge-label', 
                    sticky: false
                });
                polyline.addTo(drawnPathLayers);
            }
        }
        return totalSegmentLength;
      }

      function drawMST(mstEdges, color) {
        if (!mstEdges || mstEdges.length === 0) return 0;
        let totalWeight = 0;
        mstEdges.forEach((edge) => {
          const nodeFrom = nodes.find((n) => n.id === edge.from); 
          const nodeTo = nodes.find((n) => n.id === edge.to);     
          if (nodeFrom && nodeTo) {
            const latLngs = [
                [nodeFrom.lat, nodeFrom.lng],
                [nodeTo.lat, nodeTo.lng],
            ];
            const polyline = L.polyline(latLngs, {
                color: color,
                weight: 4,
                opacity: 0.7,
                dashArray: "5, 5",
            });

            const weightText = formatDistance(edge.weight);
            polyline.bindTooltip(weightText, {
                permanent: true,
                direction: 'center',
                className: 'edge-label',
                sticky: false
            });
            
            polyline.addTo(drawnPathLayers);
            totalWeight += edge.weight;
          }
        });
        return totalWeight;
      }

      function displayResult(
        algorithmName,
        metricValue,
        unit = "m",
        isPath = true
      ) {
        const resultId = `result-${algorithmName}`;
        let resultItem = document.getElementById(resultId);
        if (!resultItem) {
          resultItem = document.createElement("div");
          resultItem.id = resultId;
          resultItem.classList.add("result-item");
          resultsDisplay.appendChild(resultItem);
        }
        const colorBoxHTML = `<span class="color-box" style="background-color:${algorithmColors[algorithmName]};"></span>`;
        const metricType = isPath ? "Total Path Length" : "MST Total Weight";
        
        const metricDisplay = formatDistance(metricValue);

        let additionalInfo = "";
         if (metricValue === 0 && isPath) {
            const startId = parseInt(startNodeSelect.value);
            const endId = parseInt(endNodeSelect.value);
            if (startId === endId && nodes.find(n => n.id === startId) && selectedViaPoints.length === 0) {
                 additionalInfo = " (Start and end point are the same)";
            } else if (algorithmName !== "ROAD_ROUTE") {
                 additionalInfo = " (No path found or 0km)";
            } else if (nodes.length > 1){ 
                 additionalInfo = " (Route not found or 0km)";
            }
        } else if (metricValue === 0 && !isPath) { 
              additionalInfo = " (No MST formed or single point)";
        }


        resultItem.innerHTML = `${colorBoxHTML}<div><strong>${algorithmName.replace(
          /_/g,
          " "
        )}</strong>: <span class="text-gray-600">${metricType}: ${metricDisplay}${additionalInfo}</span></div>`;
      }

    function runSequentialPathfindingAlgorithm(algorithm) {
        const startId = parseInt(startNodeSelect.value);
        const endId = parseInt(endNodeSelect.value);

        if (nodes.length === 0) {
            showMessage("Please add points to the map first.", "error");
            return;
        }
        if (isNaN(startId) || isNaN(endId)) {
            showMessage("Please select valid start and end points.", "error");
            return;
        }
        
        const waypointSequence = getWaypointSequence(startId, endId, false, selectedViaPoints);

        if (!waypointSequence) { 
            clearPathsByAlgorithm(algorithm);
            displayResult(algorithm, 0, "m", true); 
            return;
        }
        if (waypointSequence.length === 1 && startId === endId && selectedViaPoints.length === 0) {
            clearPathsByAlgorithm(algorithm);
            displayResult(algorithm, 0, "m", true);
            return;
        }
        if (waypointSequence.length < 2) {
            showMessage("Sequential path requires at least two distinct points in the final sequence.", "info");
            clearPathsByAlgorithm(algorithm);
            displayResult(algorithm, 0, "m", true);
            return;
        }

        clearPathsByAlgorithm(algorithm);
        let graph, dagData, globalTopoOrder;
        let overallPathLength = 0;
        let allSegmentsFound = true;

        if (algorithm === "DAG_SP") {
            dagData = buildDirectedAcyclicGraphFromAllNodes();
            graph = dagData.adj;
            globalTopoOrder = topologicalSort(dagData.adj, dagData.inDegree, dagData.nodeIds);
            if (!globalTopoOrder) {
                showMessage("Cannot run DAG algorithm: Graph structure issue.", "error");
                displayResult(algorithm, 0, "m", true);
                return;
            }
        } else { 
            graph = buildUndirectedGraphFromAllNodes();
        }

        for (let i = 0; i < waypointSequence.length - 1; i++) {
            const segmentStartNode = waypointSequence[i]; 
            const segmentEndNode = waypointSequence[i+1]; 
            let segmentPathIds = null;

            if (segmentStartNode.id === segmentEndNode.id) continue;

            switch (algorithm) {
                case "BFS":
                    segmentPathIds = bfs(graph, segmentStartNode.id, segmentEndNode.id);
                    break;
                case "DAG_SP":
                    segmentPathIds = dagShortestPathAlgorithm(graph, globalTopoOrder, segmentStartNode.id, segmentEndNode.id, dagData.nodeIds);
                    break;
            }

            if (segmentPathIds) {
                overallPathLength += drawPathSegment(segmentPathIds, algorithmColors[algorithm]);
            } else {
                allSegmentsFound = false;
                showMessage(`No path found for segment: ${segmentStartNode.name} to ${segmentEndNode.name}.`, "warning", 2500);
            }
        }

        displayResult(algorithm, overallPathLength, "m", true);
        if (overallPathLength > 0 && allSegmentsFound) {
            showMessage(`${algorithm}: Sequential path calculated.`, "success");
        } else if (overallPathLength > 0 && !allSegmentsFound) {
            showMessage(`${algorithm}: Sequential path partially calculated. Some segments missing.`, "warning");
        } else if (overallPathLength === 0 && waypointSequence.length > 1) {
             showMessage(`${algorithm}: No segments of the sequential path could be found.`, "error");
        }
    }


    function runRoadRouteSequential() {
        clearPathsByAlgorithm("ROAD_ROUTE"); 

        let finalWaypointsForRoute = []; 

        if (selectedViaPoints.length > 0) {
            const startId = parseInt(startNodeSelect.value);
            const endId = parseInt(endNodeSelect.value);
            if (isNaN(startId) || isNaN(endId)) {
                showMessage("Please select valid Start and End points when using Via Points for Road Route.", "error");
                displayResult("ROAD_ROUTE", 0, "m", true);
                return;
            }
            // For Road Route with via points, isForRoadRoute is true, but the strict originalIndex check inside getWaypointSequence is removed.
            // The sequence will be Start -> Vias (user order) -> End.
            finalWaypointsForRoute = getWaypointSequence(startId, endId, true, selectedViaPoints); 
            if (!finalWaypointsForRoute) {
                displayResult("ROAD_ROUTE", 0, "m", true);
                return; 
            }
        } else {
            // No Via Points: use ALL placed nodes in their original placement order
            if (nodes.length < 2) {
                showMessage("Road Route (all points mode) requires at least two points on the map.", "info");
                displayResult("ROAD_ROUTE", 0, "m", true);
                return;
            }
            finalWaypointsForRoute = [...nodes].sort((a, b) => a.originalIndex - b.originalIndex);
            showMessage("Calculating Road Route for all placed points in order.", "info", 2500);
        }

        if (!finalWaypointsForRoute || finalWaypointsForRoute.length < 2) {
            if (finalWaypointsForRoute && finalWaypointsForRoute.length === 1 && 
                selectedViaPoints.length === 0 && 
                parseInt(startNodeSelect.value) === parseInt(endNodeSelect.value) ) {
                 // This case is fine, start=end, no vias
            } else if (finalWaypointsForRoute && finalWaypointsForRoute.length < 2) {
                 showMessage("Road Route requires at least two points to form a path in the final sequence.", "info");
            }
            displayResult("ROAD_ROUTE", 0, "m", true);
            return;
        }

        const waypointsForLRM = finalWaypointsForRoute.map((node) => L.latLng(node.lat, node.lng));

        if (lrmControl) {
            map.removeControl(lrmControl);
            lrmControl = null;
        }

        lrmControl = L.Routing.control({
            waypoints: waypointsForLRM,
            routeWhileDragging: false,
            show: true,
            addWaypoints: false,
            lineOptions: {
                styles: [{ color: algorithmColors.ROAD_ROUTE, opacity: 0.8, weight: 7 }],
            },
            createMarker: function () { return null; },
        })
        .on("routesfound", function (e) {
            if (e.routes && e.routes.length > 0 && e.routes[0].summary) {
                displayResult("ROAD_ROUTE", e.routes[0].summary.totalDistance, "m", true);
                showMessage("Road route found!", "success", 2000);
            } else {
                showMessage("Road route found but no distance summary or route is invalid.", "info");
                displayResult("ROAD_ROUTE", 0, "m", true);
            }
        })
        .on("routingerror", function (e) {
            console.error("Road Routing error:", e.error);
            showMessage(`Road routing error: ${e.error.message || "Could not find route."}`, "error");
            displayResult("ROAD_ROUTE", 0, "m", true);
        })
        .addTo(map);
    }

      function bfs(graph, startId, endId) {
        const visited = new Set();
        const queue = [[startId, [startId]]];
        visited.add(startId);
        while (queue.length > 0) {
          const [currentId, path] = queue.shift();
          if (currentId === endId) return path;
          const neighbors = graph[currentId] || [];
          for (const n of neighbors) {
            if (!visited.has(n.neighborId)) {
              visited.add(n.neighborId);
              queue.push([n.neighborId, [...path, n.neighborId]]);
            }
          }
        }
        return null;
      }

      function topologicalSort(adj, inDegreeInput, nodeIdsSet) {
        const q = [];
        const inDegree = JSON.parse(JSON.stringify(inDegreeInput));
        nodeIdsSet.forEach((nodeId) => {
          if (inDegree[nodeId] === 0) q.push(nodeId);
        });
        const topOrder = [];
        while (q.length > 0) {
          const u = q.shift();
          topOrder.push(u);
          if (adj[u]) {
            adj[u].forEach((edge) => {
              inDegree[edge.neighborId]--;
              if (inDegree[edge.neighborId] === 0) q.push(edge.neighborId);
            });
          }
        }
        if (topOrder.length !== nodeIdsSet.size) {
          console.error("Graph has a cycle! Topological sort failed.");
          return null;
        }
        return topOrder;
      }

      function dagShortestPathAlgorithm(
        adj, topoOrder, startNodeId, endNodeId, allNodeIdsSet ) {
        const dist = {};
        const prev = {};
        allNodeIdsSet.forEach((nodeId) => {
          dist[nodeId] = Infinity;
          prev[nodeId] = null;
        });
        dist[startNodeId] = 0;
        for (const u of topoOrder) {
          if (dist[u] === Infinity || !adj[u]) continue;
          adj[u].forEach((edge) => {
            const v = edge.neighborId;
            const weight = edge.weight;
            if (dist[v] > dist[u] + weight) {
              dist[v] = dist[u] + weight;
              prev[v] = u;
            }
          });
        }
        if (dist[endNodeId] === Infinity) return null;
        const path = [];
        let curr = endNodeId;
        while (curr !== null) {
          path.unshift(curr);
          if (curr === startNodeId) break;
          curr = prev[curr];
          if (curr === null && path[0] !== startNodeId) {
              console.error("DAGSP: Path reconstruction failed.");
              return null;
          }
        }
        return path[0] === startNodeId ? path : null;
      }

    function runMST(algorithm) {
        let activeNodesForMST = [];
        let operationMode = "all_nodes"; 

        if (selectedViaPoints.length > 0) {
            const startId = parseInt(startNodeSelect.value);
            const endId = parseInt(endNodeSelect.value);

            if (isNaN(startId) || isNaN(endId)) {
                showMessage("Please select Start and End points when using Via Points for MST.", "error");
                return;
            }
            const startNode = nodes.find(n => n.id === startId);
            const endNode = nodes.find(n => n.id === endId);

            if (!startNode || !endNode) {
                showMessage("Start or End point not found. Please ensure they are selected.", "error");
                return;
            }

            const nodeIdSet = new Set();
            if(startNode) nodeIdSet.add(startNode.id);
            selectedViaPoints.forEach(id => nodeIdSet.add(id));
            if(endNode) nodeIdSet.add(endNode.id);
            
            activeNodesForMST = Array.from(nodeIdSet).map(id => nodes.find(n => n.id === id)).filter(Boolean);
            operationMode = "subset_nodes";

            if (activeNodesForMST.length < 2) {
                showMessage(`MST on subset requires at least two unique points. Found ${activeNodesForMST.length}.`, "info");
                clearPathsByAlgorithm(algorithm);
                displayResult(algorithm, 0, "m", false);
                return;
            }
            showMessage(`Calculating MST for the subset: ${activeNodesForMST.map(n => n.name).join(', ')}.`, "info", 3000);

        } else {
            activeNodesForMST = [...nodes]; 
            operationMode = "all_nodes";
            if (activeNodesForMST.length === 0 ) { 
                showMessage("No points on the map to calculate MST.", "error");
                return;
            }
            if (activeNodesForMST.length < 2) {
                showMessage("MST requires at least two points. Add more points on the map.", "info");
                if (activeNodesForMST.length === 1) { 
                    clearPathsByAlgorithm(algorithm);
                    displayResult(algorithm, 0, "m", false); 
                }
                return;
            }
        }

        let mstEdges = null;
        let mstWeight = 0;
        clearPathsByAlgorithm(algorithm);

        switch (algorithm) {
            case "PRIMS":
                mstEdges = primsAlgorithm(activeNodesForMST);
                break;
            case "KRUSKALS":
                mstEdges = kruskalsAlgorithm(activeNodesForMST);
                break;
        }

        if (mstEdges && mstEdges.length > 0) {
            mstWeight = drawMST(mstEdges, algorithmColors[algorithm]);
            showMessage(`${algorithm}'s MST calculated${operationMode === "subset_nodes" ? " for the subset" : ""}.`, "success");
        } else if (activeNodesForMST.length >= 2 ) { 
            showMessage(`${algorithm}'s MST could not be formed${operationMode === "subset_nodes" ? " for the subset" : ""}. (e.g. not enough points for edges)`, "info");
        } else if (activeNodesForMST.length === 1 && operationMode === "subset_nodes") {
             showMessage(`${algorithm}'s MST for a single point in subset is 0.`, "info");
        }

        displayResult(algorithm, mstWeight, "m", false);
    }

      function primsAlgorithm(activeNodes) { 
        if (!activeNodes || activeNodes.length < 1) return []; 
        if (activeNodes.length === 1) return []; 

        const mstEdges = [];
        const visited = new Set();
        const H = new PriorityQueue();
        
        const startNodeId = activeNodes[0].id; 
        visited.add(startNodeId);

        const adjList = buildUndirectedGraphFromSpecificNodes(activeNodes); 

        (adjList[startNodeId] || []).forEach((edge) =>
          H.enqueue( { to: edge.neighborId, weight: edge.weight, from: startNodeId }, edge.weight )
        );

        while (!H.isEmpty() && visited.size < activeNodes.length) {
          const { to: toNodeId, weight, from: fromNodeId } = H.dequeue().element;
          if (visited.has(toNodeId)) continue;
          
          visited.add(toNodeId);
          mstEdges.push({ from: fromNodeId, to: toNodeId, weight: weight });

          (adjList[toNodeId] || []).forEach((nEdge) => {
            if (!visited.has(nEdge.neighborId))
              H.enqueue( { to: nEdge.neighborId, weight: nEdge.weight, from: toNodeId }, nEdge.weight );
          });
        }
        return mstEdges;
      }

      function kruskalsAlgorithm(activeNodes) { 
        if (!activeNodes || activeNodes.length < 2) return []; 

        const mstEdges = [];
        const allEdges = [];

        for (let i = 0; i < activeNodes.length; i++) {
            for (let j = i + 1; j < activeNodes.length; j++) {
                allEdges.push({
                    from: activeNodes[i].id,
                    to: activeNodes[j].id,
                    weight: getDistance(activeNodes[i], activeNodes[j]),
                });
            }
        }
            
        allEdges.sort((a, b) => a.weight - b.weight);
        
        const dsu = new DisjointSetUnion(activeNodes.map((n) => n.id)); 

        for (const edge of allEdges) {
            if (dsu.find(edge.from) !== dsu.find(edge.to)) {
                mstEdges.push(edge);
                dsu.union(edge.from, edge.to);
                if (activeNodes.length > 0 && mstEdges.length === activeNodes.length - 1) break; 
            }
        }
        return mstEdges;
      }
      class DisjointSetUnion {
        constructor(elements) {
          this.parent = {};
          this.rank = {};
          elements.forEach((el) => {
            this.parent[el] = el;
            this.rank[el] = 0;
          });
        }
        find(el) {
          if (this.parent[el] !== el)
            this.parent[el] = this.find(this.parent[el]);
          return this.parent[el];
        }
        union(el1, el2) {
          const r1 = this.find(el1);
          const r2 = this.find(el2);
          if (r1 !== r2) {
            if (this.rank[r1] < this.rank[r2]) this.parent[r1] = r2;
            else if (this.rank[r1] > this.rank[r2]) this.parent[r2] = r1;
            else {
              this.parent[r2] = r1;
              this.rank[r1]++;
            }
            return true;
          }
          return false;
        }
      }
      class PriorityQueue {
        constructor() {
          this.items = [];
        }
        enqueue(element, priority) {
          const qE = { element, priority };
          let added = false;
          for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].priority > qE.priority) {
              this.items.splice(i, 0, qE);
              added = true;
              break;
            }
          }
          if (!added) this.items.push(qE);
        }
        dequeue() {
          if (this.isEmpty()) return null;
          return this.items.shift();
        }
        isEmpty() {
          return this.items.length === 0;
        }
        contains(element) {
            return this.items.some(item => item.element === element);
        }
        updatePriority(element, newPriority) {
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].element === element) {
                    this.items.splice(i, 1);
                    this.enqueue(element, newPriority);
                    return;
                }
            }
        }
      }

      function clearPathsByAlgorithm(algorithmName) {
        if (algorithmName === "ROAD_ROUTE") {
          if (lrmControl) {
            map.removeControl(lrmControl);
            lrmControl = null;
          }
        } else {
          const colorToClear = algorithmColors[algorithmName];
          const layersToRemove = [];
          drawnPathLayers.eachLayer((layer) => {
            if (layer.options && layer.options.color === colorToClear) {
                 layersToRemove.push(layer);
            }
          });
          layersToRemove.forEach((layer) => drawnPathLayers.removeLayer(layer));
        }
        const resultItem = document.getElementById(`result-${algorithmName}`);
        if (resultItem) resultItem.remove();
      }

      document.addEventListener("DOMContentLoaded", () => {
        initMap();
        setupEventListeners();
        updateModeDisplay();
        updatePointsListUI();
        updateViaPointsListUI(); 
      });
    </script>
  </body>
</html>
